################################### Алгоритмы сортировок #########################################

# Сортировка вставками (Insertion Sort)
def insert_sorting(unsorting):
    """
    алгоритм сортировки, на каждом шаге которого массив постепенно перебирается слева направо. 
    При этом каждый последующий элемент размещается так, чтобы он оказался между ближайшими 
    элементами с минимальным и максимальным значением.
    """

    for i in range(1, len(unsorting)):
        j = i
        temp = unsorting[i]
        while j > 0 and unsorting[j-1] > temp:
            unsorting[j] = unsorting[j-1]
            j -= 1 
        unsorting[j] = temp

    return unsorting 



# Алгоритм сортировки слиянием

def merge(A, aux, low, mid, high):
    # Объединить два отсортированных подсписка `A[low … mid]` и `A[mid+1 … high]`
    k = low
    i = low
    j = mid + 1
    while i <= mid and j <= high:                               # при наличии элементов в левом и правом прогонах
        if A[i] <= A[j]:
            aux[k] = A[i]
            k = k + 1
            i = i + 1
        else:
            aux[k] = A[j]
            k = k + 1
            j = j + 1
    while i <= mid:                                             # скопировать оставшиеся элементы
        aux[k] = A[i]
        k = k + 1
        i = i + 1
 
 # Копировать вторую половину не нужно (поскольку остальные элементы уже находятся в правильном положении во вспомогательном массиве)
 
    # скопировать обратно в исходный список, чтобы отразить порядок сортировки
    for i in range(low, high + 1):
        A[i] = aux[i]
 
 
# Список сортировки `A[low…high]` с использованием вспомогательного вспомогательного списка
def mergesort(A, aux, low, high):
 
    # Базовый вариант
    if high <= low:                     #, если размер прогона <= 1
        return
 
    # найти среднюю точку
    mid = (low + ((high - low) >> 1))
 
    # рекурсивно разделяет прогоны на две половины до тех пор, пока размер прогона не станет <= 1,
    #, затем объедините их и вернитесь вверх по цепочке вызовов.
 
    mergesort(A, aux, low, mid)         # разделить/объединить левую половину
    mergesort(A, aux, mid + 1, high)    # разделить/объединить правую половину
 
    merge(A, aux, low, mid, high)       # объединяет две половины пробега
 
 
   



# Функция для проверки, отсортирован ли `A` в порядке возрастания или нет
def isSorted(A):
 
    prev = A[0]
    for i in range(1, len(A)):
        if prev > A[i]:
            print("MergeSort Fails!!")
            return False
 
        prev = A[i]
 
    return True
 
 

# Реализация алгоритмов сортировок
if __name__ == '__main__':
    A = [12, 3, 18, 24, 0, 5, -2]   # не отсортированная последовательность

    insert_sorting(A)               # сортировка вставками

    #aux = A.copy()
    # отсортировать список `A`, используя вспомогательный список `aux`
    #mergesort(A, aux, 0, len(A) - 1)


    if isSorted(A):                 # если последовательность отсоритрована
        print(A)                    # выводим